// Example frontend usage with MetaMask for P2PPay contract
// Include this in a web page and host it with a static server (e.g., `npx http-server`)
// The script expects to find `frontend/p2ppay.json` generated by `node scripts/export_frontend_artifact.js`.

// Almacenar el provider y signer actuales
let currentProvider = null
let currentSigner = null
let currentAccount = null

async function connectWallet() {
  if (!window.ethereum) {
    console.warn('MetaMask not found in this browser.')
    throw new Error('MetaMask not found')
  }
  await window.ethereum.request({ method: 'eth_requestAccounts' })
  currentProvider = new ethers.providers.Web3Provider(window.ethereum)
  currentSigner = currentProvider.getSigner()
  currentAccount = await currentSigner.getAddress()
  return { provider: currentProvider, signer: currentSigner }
}

// Obtener todas las cuentas disponibles de MetaMask
async function getAllAccounts() {
  if (!window.ethereum) {
    throw new Error('MetaMask not found')
  }
  
  // Primero intentar obtener las cuentas ya autorizadas
  let accounts = await window.ethereum.request({ method: 'eth_accounts' })
  
  // Si no hay cuentas conectadas, solicitar conexión
  if (accounts.length === 0) {
    accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })
  }
  
  // Intentar obtener todas las cuentas usando wallet_getPermissions
  // Esto puede devolver más cuentas si el usuario ha autorizado múltiples
  try {
    const permissions = await window.ethereum.request({ 
      method: 'wallet_getPermissions' 
    })
    
    // Si hay permisos, intentar obtener todas las cuentas autorizadas
    if (permissions && permissions.length > 0) {
      const ethAccountsPermission = permissions.find(
        p => p.parentCapability === 'eth_accounts'
      )
      if (ethAccountsPermission && ethAccountsPermission.caveats) {
        const accountsCaveat = ethAccountsPermission.caveats.find(
          c => c.type === 'restrictReturnedAccounts'
        )
        if (accountsCaveat && accountsCaveat.value) {
          // Devolver todas las cuentas autorizadas
          return accountsCaveat.value
        }
      }
    }
  } catch (e) {
    console.warn('Could not get permissions, using default account:', e)
  }
  
  // Si solo tenemos una cuenta, intentar solicitar acceso a todas
  // Nota: MetaMask puede no permitir esto, pero lo intentamos
  if (accounts.length === 1) {
    try {
      // Solicitar permiso para todas las cuentas (puede no funcionar en todas las versiones)
      await window.ethereum.request({
        method: 'wallet_requestPermissions',
        params: [{ eth_accounts: {} }]
      })
      // Intentar obtener de nuevo
      const newAccounts = await window.ethereum.request({ method: 'eth_accounts' })
      if (newAccounts.length > accounts.length) {
        return newAccounts
      }
    } catch (e) {
      console.warn('Could not request additional accounts:', e)
    }
  }
  
  return accounts
}

// Cambiar a una cuenta específica
async function switchAccount(address) {
  if (!window.ethereum) {
    throw new Error('MetaMask not found')
  }
  
  // Verificar que la cuenta esté disponible
  const accounts = await getAllAccounts()
  if (!accounts.includes(address)) {
    throw new Error('Account not found in MetaMask')
  }
  
  // Actualizar el signer con la nueva cuenta
  if (!currentProvider) {
    currentProvider = new ethers.providers.Web3Provider(window.ethereum)
  }
  currentSigner = currentProvider.getSigner(address)
  currentAccount = address
  
  // Emitir evento de cambio de cuenta
  window.dispatchEvent(new CustomEvent('accountChanged', { detail: { address } }))
  
  return { provider: currentProvider, signer: currentSigner, address }
}

// Obtener el signer actual (para usar en las funciones)
function getCurrentSigner() {
  if (!currentSigner) {
    throw new Error('Wallet not connected. Please connect MetaMask first.')
  }
  return currentSigner
}

async function payTo(payee, amountEther, reference) {
  // Usar el signer actual en lugar de conectar de nuevo
  const signer = getCurrentSigner()
  const res = await fetch('/p2ppay.json')
  const info = await res.json()
  const contractAddress = info.address
  const contractAbi = info.abi
  const contract = new ethers.Contract(contractAddress, contractAbi, signer)
  const tx = await contract.payTo(payee, ethers.utils.formatBytes32String(reference || ''), { value: ethers.utils.parseEther(amountEther) })
  await tx.wait()
  return tx
}

async function withdraw() {
  // Usar el signer actual en lugar de conectar de nuevo
  const signer = getCurrentSigner()
  const res = await fetch('/p2ppay.json')
  const info = await res.json()
  const contractAddress = info.address
  const contractAbi = info.abi
  const contract = new ethers.Contract(contractAddress, contractAbi, signer)
  try {
    const tx = await contract.withdraw()
    await tx.wait()
    return tx
  } catch (err) {
    // Provide a clearer error for common revert reasons
    if (err && err.message && err.message.includes('no funds')) {
      throw new Error('No funds to withdraw for this account')
    }
    throw err
  }
}

async function fundProjectWallet(projectAddress, amountEther, reference) {
  // Use payTo helper - it already connects to signer and calls contract.payTo with a bytes32 ref
  return payTo(projectAddress, amountEther, reference)
}

// Export for browser usage
window.P2P = { 
  connectWallet, 
  payTo, 
  withdraw, 
  fundProjectWallet,
  getAllAccounts,
  switchAccount,
  getCurrentSigner
}
// Debug log to confirm this file loaded and registered APIs correctly
try { console.log('metamask_p2p loaded, P2P keys:', Object.keys(window.P2P)) } catch (e) { console.warn('metamask_p2p: unable to log P2P', e) }

// Escuchar cambios de cuenta en MetaMask
if (window.ethereum) {
  window.ethereum.on('accountsChanged', (accounts) => {
    if (accounts.length === 0) {
      // Usuario desconectó MetaMask
      currentProvider = null
      currentSigner = null
      currentAccount = null
      window.dispatchEvent(new CustomEvent('accountDisconnected'))
    } else {
      // Usuario cambió de cuenta en MetaMask
      const newAccount = accounts[0]
      if (currentProvider) {
        currentSigner = currentProvider.getSigner(newAccount)
        currentAccount = newAccount
        window.dispatchEvent(new CustomEvent('accountChanged', { detail: { address: newAccount } }))
      }
    }
  })
}
